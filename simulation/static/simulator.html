<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>íŠ¸ëŸ­ ì ì¬ ì‹œë®¬ë ˆì´ì…˜</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
      touch-action: none;
    }

    #container {
      display: flex;
      height: 100vh;
      height: 100dvh;
    }

    /* ì‚¬ì´ë“œë°” (ê°€êµ¬ ëª©ë¡) */
    #sidebar {
      width: 140px;
      background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
      padding: 12px 8px;
      overflow-y: auto;
      border-right: 1px solid #dee2e6;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    #sidebar h3 {
      font-size: 14px;
      color: #495057;
      padding-bottom: 8px;
      border-bottom: 1px solid #dee2e6;
      margin-bottom: 4px;
    }

    .furniture-item {
      padding: 10px 8px;
      background: white;
      border-radius: 10px;
      cursor: pointer;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      transition: all 0.2s ease;
      border: 2px solid transparent;
    }

    .furniture-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .furniture-item.placed {
      opacity: 0.4;
      cursor: not-allowed;
      border-color: #28a745;
    }

    .furniture-item.selected {
      border-color: #007bff;
      background: #e7f1ff;
    }

    .furniture-icon { font-size: 28px; margin-bottom: 4px; }
    .furniture-name { font-size: 11px; color: #495057; font-weight: 500; }
    .furniture-size { font-size: 9px; color: #868e96; margin-top: 2px; }

    /* ìº”ë²„ìŠ¤ ì»¨í…Œì´ë„ˆ */
    #canvas-container {
      flex: 1;
      position: relative;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    /* ìƒë‹¨ ì»¨íŠ¸ë¡¤ */
    #top-controls {
      position: absolute;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 100;
    }

    #truck-selector { display: flex; gap: 6px; }

    .truck-btn {
      padding: 8px 12px;
      border: none;
      border-radius: 8px;
      background: rgba(255,255,255,0.9);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .truck-btn:hover { background: white; transform: scale(1.05); }
    .truck-btn.active { background: #007bff; color: white; }

    #action-buttons { display: flex; gap: 8px; }

    .btn {
      padding: 10px 16px;
      border: none;
      border-radius: 10px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .btn-primary { background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); color: white; }
    .btn-secondary { background: rgba(255,255,255,0.9); color: #495057; }
    .btn-danger { background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); color: white; }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }

    /* í•˜ë‹¨ í†µê³„ */
    #stats-panel {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.85);
      color: white;
      padding: 16px 24px;
      border-radius: 16px;
      display: flex;
      gap: 32px;
      backdrop-filter: blur(10px);
      z-index: 100;
    }

    .stat-item { text-align: center; }
    .stat-value { font-size: 28px; font-weight: 700; color: #4dabf7; }
    .stat-value.warning { color: #ffc107; }
    .stat-value.danger { color: #ff6b6b; }
    .stat-label { font-size: 11px; color: #adb5bd; margin-top: 4px; }

    /* ì„ íƒëœ ê°€êµ¬ ì •ë³´ - ë†’ì´ ì¡°ì ˆ ì¶”ê°€ */
    #selected-info {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.95);
      padding: 12px 20px;
      border-radius: 12px;
      display: none;
      align-items: center;
      gap: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      z-index: 100;
    }

    #selected-info.visible { display: flex; }
    #selected-info .name { font-weight: 600; color: #212529; }
    #selected-info .size { font-size: 12px; color: #868e96; }
    #selected-info .height-info { font-size: 11px; color: #007bff; font-weight: 500; }

    .control-btn {
      padding: 8px 12px;
      border: 1px solid #dee2e6;
      border-radius: 8px;
      background: white;
      cursor: pointer;
      font-size: 14px;
    }

    .control-btn:hover { background: #f8f9fa; }
    .control-btn.danger { background: #ff6b6b; color: white; border: none; }

    .height-controls {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .height-btn {
      padding: 4px 10px;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      background: white;
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
    }

    .height-btn:hover { background: #e7f1ff; border-color: #007bff; }

    /* ë„ì›€ë§ */
    #help-tooltip {
      position: absolute;
      top: 60px;
      right: 12px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 12px 16px;
      border-radius: 10px;
      font-size: 12px;
      line-height: 1.6;
      max-width: 220px;
      display: none;
      z-index: 100;
    }

    #help-tooltip.visible { display: block; }

    /* ë¡œë”© */
    #loading {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255,255,255,0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 200;
    }

    #loading.hidden { display: none; }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid #007bff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #loading-text { margin-top: 16px; color: #495057; font-size: 14px; }

    /* ëª¨ë“œ í‘œì‹œ */
    #mode-indicator {
      position: absolute;
      top: 60px;
      left: 12px;
      background: rgba(0,0,0,0.7);
      color: #4dabf7;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 12px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <div id="loading-text">ì‹œë®¬ë ˆì´í„° ë¡œë”© ì¤‘...</div>
  </div>

  <div id="container">
    <div id="sidebar">
      <h3>ê°€êµ¬ ëª©ë¡</h3>
      <div id="furniture-list"></div>
    </div>

    <div id="canvas-container">
      <div id="top-controls">
        <div id="truck-selector">
          <button class="truck-btn" data-truck="1ton">1í†¤</button>
          <button class="truck-btn active" data-truck="2.5ton">2.5í†¤</button>
          <button class="truck-btn" data-truck="5ton">5í†¤</button>
        </div>
        <div id="action-buttons">
          <button class="btn btn-secondary" onclick="toggleHelp()">?</button>
          <button class="btn btn-secondary" onclick="resetCamera()">ì¹´ë©”ë¼</button>
          <button class="btn btn-secondary" onclick="autoPlace()">ë¡œì»¬ BLF</button>
          <button class="btn btn-primary" onclick="serverOptimize()">ì„œë²„ ìµœì í™”</button>
          <button class="btn btn-danger" onclick="clearAll()">ì´ˆê¸°í™”</button>
        </div>
      </div>

      <div id="mode-indicator">XZ ì´ë™ | W/S: ë†’ì´ ì¡°ì ˆ</div>

      <div id="help-tooltip">
        <b>ì¡°ì‘ ë°©ë²•</b><br>
        - ê°€êµ¬ í´ë¦­: íŠ¸ëŸ­ì— ë°°ì¹˜<br>
        - ë“œë˜ê·¸: ê°€êµ¬ XZ ì´ë™<br>
        - W / S í‚¤: ë†’ì´ ì˜¬ë¦¬ê¸°/ë‚´ë¦¬ê¸°<br>
        - R í‚¤: 90ë„ íšŒì „<br>
        - Delete: ì œê±°<br>
        - ë‘ ì†ê°€ë½: ì¹´ë©”ë¼ íšŒì „/ì¤Œ
      </div>

      <div id="selected-info">
        <div>
          <div class="name" id="selected-name">ì†ŒíŒŒ</div>
          <div class="size" id="selected-size">200 x 90 x 85 cm</div>
          <div class="height-info" id="selected-height">ë†’ì´: 0 cm</div>
        </div>
        <div class="height-controls">
          <button class="height-btn" onclick="moveSelectedUp()">W</button>
          <button class="height-btn" onclick="moveSelectedDown()">S</button>
        </div>
        <button class="control-btn" onclick="rotateSelected()">90Â°</button>
        <button class="control-btn danger" onclick="removeSelected()">X</button>
      </div>

      <div id="stats-panel">
        <div class="stat-item">
          <div class="stat-value" id="load-percent">0</div>
          <div class="stat-label">ì ì¬ìœ¨ %</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="placed-count">0</div>
          <div class="stat-label">ë°°ì¹˜ë¨</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="total-count">0</div>
          <div class="stat-label">ì „ì²´</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="weight-total">0</div>
          <div class="stat-label">ë¬´ê²Œ kg</div>
        </div>
      </div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { DragControls } from 'three/addons/controls/DragControls.js';
    import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';

    // ==================== ì „ì—­ ìƒíƒœ ====================
    let scene, camera, renderer, orbitControls, dragControls;
    let truckMesh, truckFloor, truckWalls = [];
    let furnitureData = [];
    let furnitureObjects = [];
    let placedFurniture = [];
    let selectedObject = null;
    let estimateId = null;

    const plyLoader = new PLYLoader();
    const HEIGHT_STEP = 0.1; // ë†’ì´ ì¡°ì ˆ ë‹¨ìœ„ (10cm)

    const TRUCK_SPECS = {
      "1ton": { name: "1í†¤", width: 1.7, depth: 2.8, height: 1.7, maxWeight: 1000 },
      "2.5ton": { name: "2.5í†¤", width: 2.0, depth: 4.3, height: 1.9, maxWeight: 2500 },
      "5ton": { name: "5í†¤", width: 2.3, depth: 6.2, height: 2.4, maxWeight: 5000 },
    };

    let currentTruck = TRUCK_SPECS["2.5ton"];

    // ==================== ì´ˆê¸°í™” ====================
    function init() {
      const container = document.getElementById('canvas-container');

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e);

      camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
      camera.position.set(6, 5, 6);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(10, 15, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // Ground
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(20, 20),
        new THREE.MeshStandardMaterial({ color: 0x2d2d44, roughness: 0.8 })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.01;
      ground.receiveShadow = true;
      scene.add(ground);

      const gridHelper = new THREE.GridHelper(20, 20, 0x444466, 0x333355);
      scene.add(gridHelper);

      // Controls
      orbitControls = new OrbitControls(camera, renderer.domElement);
      orbitControls.enableDamping = true;
      orbitControls.dampingFactor = 0.05;
      orbitControls.target.set(0, 1, 0);
      orbitControls.maxPolarAngle = Math.PI / 2 - 0.1;

      createTruck(currentTruck);
      setupEventListeners();
      animate();

      const params = new URLSearchParams(window.location.search);
      estimateId = params.get('estimate_id');

      if (estimateId) {
        loadSimulationData(estimateId);
      } else {
        loadSampleData();
      }
    }

    // ==================== íŠ¸ëŸ­ ìƒì„± ====================
    function createTruck(spec) {
      if (truckMesh) scene.remove(truckMesh);
      if (truckFloor) scene.remove(truckFloor);
      truckWalls.forEach(w => scene.remove(w));
      truckWalls = [];

      const { width, depth, height } = spec;

      // íŠ¸ëŸ­ í”„ë ˆì„
      const geometry = new THREE.BoxGeometry(width, height, depth);
      const edges = new THREE.EdgesGeometry(geometry);
      truckMesh = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ff88 }));
      truckMesh.position.set(0, height / 2, 0);
      scene.add(truckMesh);

      // ë°”ë‹¥
      truckFloor = new THREE.Mesh(
        new THREE.PlaneGeometry(width, depth),
        new THREE.MeshStandardMaterial({ color: 0x00ff88, transparent: true, opacity: 0.2, side: THREE.DoubleSide })
      );
      truckFloor.rotation.x = -Math.PI / 2;
      truckFloor.position.y = 0.005;
      scene.add(truckFloor);

      // ë²½ë©´
      const wallMaterial = new THREE.MeshStandardMaterial({
        color: 0x00ff88, transparent: true, opacity: 0.08, side: THREE.DoubleSide
      });

      const backWall = new THREE.Mesh(new THREE.PlaneGeometry(width, height), wallMaterial);
      backWall.position.set(0, height / 2, -depth / 2);
      scene.add(backWall);
      truckWalls.push(backWall);

      const sideWallL = new THREE.Mesh(new THREE.PlaneGeometry(depth, height), wallMaterial);
      sideWallL.rotation.y = Math.PI / 2;
      sideWallL.position.set(-width / 2, height / 2, 0);
      scene.add(sideWallL);
      truckWalls.push(sideWallL);

      const sideWallR = sideWallL.clone();
      sideWallR.position.x = width / 2;
      scene.add(sideWallR);
      truckWalls.push(sideWallR);
    }

    // ==================== ë°ì´í„° ë¡œë“œ ====================
    async function loadSimulationData(estId) {
      setLoading(true, 'ê°€êµ¬ ë°ì´í„° ë¡œë”© ì¤‘...');
      try {
        const response = await fetch(`/simulation/data/${estId}`);
        if (!response.ok) throw new Error('Failed');
        const data = await response.json();

        if (data.truck) {
          currentTruck = data.truck;
          createTruck(currentTruck);
        }

        furnitureData = data.furniture || [];
        await loadFurnitureItems(furnitureData);
        updateUI();
        setLoading(false);
      } catch (error) {
        console.error('Error:', error);
        loadSampleData();
      }
    }

    async function loadSampleData() {
      // API í˜¸ì¶œë¡œ ì‹¤ì œ PLY íŒŒì¼ í¬í•¨ëœ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
      try {
        const res = await fetch('/simulation/data/123');
        const data = await res.json();
        furnitureData = data.furniture || [];
        await loadFurnitureItems(furnitureData);
        updateUI();
        setLoading(false);
      } catch (err) {
        console.error('API í˜¸ì¶œ ì‹¤íŒ¨, ë°•ìŠ¤ ë°ì´í„° ì‚¬ìš©:', err);
        // í´ë°±: ë°•ìŠ¤ë§Œ
        furnitureData = [
          { id: 'sofa_001', label: 'sofa', label_ko: '3ì¸ ì†ŒíŒŒ', width: 2.0, depth: 0.9, height: 0.85, weight: 45, color: '#4a90d9' },
          { id: 'table_001', label: 'table', label_ko: 'ì‹íƒ', width: 1.6, depth: 0.9, height: 0.75, weight: 35, color: '#8b4513' },
          { id: 'chair_001', label: 'chair', label_ko: 'ì˜ì', width: 0.45, depth: 0.45, height: 0.9, weight: 5, color: '#2e8b57' },
        ];
        await loadFurnitureItems(furnitureData);
        updateUI();
        setLoading(false);
      }
    }

    async function loadFurnitureItems(items) {
      furnitureObjects = [];
      let loadedCount = 0;

      for (const item of items) {
        setLoading(true, `ê°€êµ¬ ë¡œë”© ì¤‘... (${++loadedCount}/${items.length})`);
        const mesh = await createFurnitureMesh(item);
        furnitureObjects.push(mesh);
      }

      createSidebar(items);
      document.getElementById('total-count').textContent = items.length;
    }

    async function createFurnitureMesh(item) {
      return new Promise((resolve) => {
        const { width, height, depth, color, ply_url } = item;

        if (ply_url) {
          plyLoader.load(
            ply_url,
            (geometry) => {
              geometry.computeBoundingBox();
              const bbox = geometry.boundingBox;
              const size = new THREE.Vector3();
              bbox.getSize(size);

              // ì¤‘ì‹¬ ë§ì¶”ê¸°
              geometry.center();

              const scale = Math.min(width / size.x, height / size.y, depth / size.z);

              // í¬ì¸íŠ¸ í´ë¼ìš°ë“œë¡œ ë Œë”ë§ (Gaussian Splat PLY)
              const material = new THREE.PointsMaterial({
                size: 0.005,
                vertexColors: geometry.hasAttribute('color'),
                sizeAttenuation: true,
              });

              const points = new THREE.Points(geometry, material);
              points.scale.setScalar(scale);
              points.userData = { ...item, placed: false, baseY: height / 2, isPoints: true };
              points.visible = false;

              scene.add(points);
              console.log(`PLY í¬ì¸íŠ¸ í´ë¼ìš°ë“œ ë¡œë“œ ì„±ê³µ: ${item.label} (${geometry.attributes.position.count} points)`);
              resolve(points);
            },
            (progress) => {
              if (progress.total) {
                const pct = Math.round((progress.loaded / progress.total) * 100);
                setLoading(true, `${item.label} ë¡œë”©... ${pct}%`);
              }
            },
            (error) => {
              console.warn(`PLY ë¡œë“œ ì‹¤íŒ¨: ${item.label}, ë°•ìŠ¤ë¡œ ëŒ€ì²´`, error);
              resolve(createBoxMesh(item));
            }
          );
        } else {
          resolve(createBoxMesh(item));
        }
      });
    }

    function createBoxMesh(item) {
      const { width, height, depth, color } = item;

      const geometry = new THREE.BoxGeometry(width, height, depth);
      const material = new THREE.MeshStandardMaterial({
        color: color || 0x888888,
        roughness: 0.7,
        metalness: 0.1,
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData = { ...item, placed: false, baseY: height / 2 };
      mesh.visible = false;

      scene.add(mesh);
      return mesh;
    }

    // ==================== UI ====================
    function createSidebar(items) {
      const container = document.getElementById('furniture-list');
      container.innerHTML = '';

      items.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'furniture-item';
        div.id = `item-${index}`;
        div.innerHTML = `
          <div class="furniture-icon">${getEmoji(item.label)}</div>
          <div class="furniture-name">${item.label_ko || item.label}</div>
          <div class="furniture-size">${(item.width * 100).toFixed(0)}x${(item.depth * 100).toFixed(0)}</div>
        `;
        div.onclick = () => placeFurniture(index);
        container.appendChild(div);
      });
    }

    function getEmoji(label) {
      const l = label.toLowerCase();
      if (l.includes('sofa')) return 'ğŸ›‹ï¸';
      if (l.includes('chair')) return 'ğŸª‘';
      if (l.includes('table')) return 'ğŸ½ï¸';
      if (l.includes('desk')) return 'ğŸ–¥ï¸';
      if (l.includes('bed')) return 'ğŸ›ï¸';
      if (l.includes('wardrobe') || l.includes('closet')) return 'ğŸšª';
      if (l.includes('cabinet')) return 'ğŸ—„ï¸';
      return 'ğŸ“¦';
    }

    function updateUI() {
      updateStats();
      updateSelectedInfo();
    }

    function updateStats() {
      const truckVolume = currentTruck.width * currentTruck.depth * currentTruck.height;
      let placedVolume = 0;
      let totalWeight = 0;

      placedFurniture.forEach((mesh) => {
        const { width, depth, height, weight } = mesh.userData;
        placedVolume += width * depth * height;
        totalWeight += weight || 0;
      });

      const loadPercent = Math.round((placedVolume / truckVolume) * 100);

      const loadEl = document.getElementById('load-percent');
      loadEl.textContent = loadPercent;
      loadEl.className = 'stat-value' + (loadPercent > 90 ? ' danger' : loadPercent > 70 ? ' warning' : '');

      document.getElementById('placed-count').textContent = placedFurniture.length;

      const weightEl = document.getElementById('weight-total');
      weightEl.textContent = totalWeight;
      weightEl.className = 'stat-value' + (totalWeight > currentTruck.maxWeight ? ' danger' : '');

      sendStateToApp();
    }

    function updateSelectedInfo() {
      const infoPanel = document.getElementById('selected-info');

      if (selectedObject) {
        infoPanel.classList.add('visible');
        document.getElementById('selected-name').textContent = selectedObject.userData.label_ko || selectedObject.userData.label;
        document.getElementById('selected-size').textContent =
          `${(selectedObject.userData.width * 100).toFixed(0)} x ${(selectedObject.userData.depth * 100).toFixed(0)} x ${(selectedObject.userData.height * 100).toFixed(0)} cm`;

        // ë°”ë‹¥ìœ¼ë¡œë¶€í„°ì˜ ë†’ì´ ê³„ì‚°
        const floorY = selectedObject.position.y - selectedObject.userData.height / 2;
        document.getElementById('selected-height').textContent = `ë°”ë‹¥ì—ì„œ ë†’ì´: ${(floorY * 100).toFixed(0)} cm`;
      } else {
        infoPanel.classList.remove('visible');
      }
    }

    function setLoading(show, text = 'ë¡œë”© ì¤‘...') {
      document.getElementById('loading').classList.toggle('hidden', !show);
      document.getElementById('loading-text').textContent = text;
    }

    // ==================== ê°€êµ¬ ë°°ì¹˜ ====================
    function placeFurniture(index) {
      const mesh = furnitureObjects[index];
      if (!mesh || mesh.userData.placed) return;

      mesh.userData.placed = true;
      mesh.visible = true;
      mesh.position.set(0, mesh.userData.height / 2, 0);

      placedFurniture.push(mesh);
      document.getElementById(`item-${index}`).classList.add('placed');

      setupDragControls();
      updateStats();
      selectObject(mesh);
    }

    function setupDragControls() {
      if (dragControls) dragControls.dispose();

      dragControls = new DragControls(placedFurniture, camera, renderer.domElement);

      dragControls.addEventListener('dragstart', (event) => {
        orbitControls.enabled = false;
        selectObject(event.object);
      });

      dragControls.addEventListener('drag', (event) => {
        const obj = event.object;
        // XZ í‰ë©´ì—ì„œë§Œ ì´ë™ (YëŠ” í‚¤ë³´ë“œë¡œ)
        // í˜„ì¬ Y ìœ„ì¹˜ ìœ ì§€
        const currentY = obj.position.y;
        clampToTruck(obj);
        obj.position.y = currentY; // Y ë³µì›
        updateSelectedInfo();
      });

      dragControls.addEventListener('dragend', () => {
        orbitControls.enabled = true;
        updateStats();
      });
    }

    function clampToTruck(obj) {
      const { width, depth, height } = obj.userData;
      const hw = currentTruck.width / 2 - width / 2;
      const hd = currentTruck.depth / 2 - depth / 2;

      obj.position.x = Math.max(-hw, Math.min(hw, obj.position.x));
      obj.position.z = Math.max(-hd, Math.min(hd, obj.position.z));

      // Y ë²”ìœ„ ì œí•œ: ë°”ë‹¥ ~ íŠ¸ëŸ­ ì²œì¥
      const minY = height / 2;
      const maxY = currentTruck.height - height / 2;
      obj.position.y = Math.max(minY, Math.min(maxY, obj.position.y));
    }

    function selectObject(obj) {
      // ì´ì „ ì„ íƒ í•´ì œ
      if (selectedObject && selectedObject !== obj) {
        selectedObject.material.emissive?.setHex(0x000000);
      }

      selectedObject = obj;

      furnitureObjects.forEach((m, i) => {
        document.getElementById(`item-${i}`)?.classList.remove('selected');
      });

      if (obj) {
        const index = furnitureObjects.indexOf(obj);
        document.getElementById(`item-${index}`)?.classList.add('selected');

        // ì„ íƒ í‘œì‹œ (ë°œê´‘)
        if (obj.material.emissive) {
          obj.material.emissive.setHex(0x333333);
        }
      }

      updateSelectedInfo();
    }

    // ==================== ë†’ì´ ì¡°ì ˆ ====================
    window.moveSelectedUp = function() {
      if (!selectedObject) return;
      selectedObject.position.y += HEIGHT_STEP;
      clampToTruck(selectedObject);
      updateSelectedInfo();
      updateStats();
    };

    window.moveSelectedDown = function() {
      if (!selectedObject) return;
      selectedObject.position.y -= HEIGHT_STEP;
      clampToTruck(selectedObject);
      updateSelectedInfo();
      updateStats();
    };

    // ==================== ì•¡ì…˜ ====================
    window.rotateSelected = function() {
      if (!selectedObject) return;
      selectedObject.rotation.y += Math.PI / 2;

      // ì¹˜ìˆ˜ ìŠ¤ì™‘
      const temp = selectedObject.userData.width;
      selectedObject.userData.width = selectedObject.userData.depth;
      selectedObject.userData.depth = temp;

      clampToTruck(selectedObject);
      updateSelectedInfo();
    };

    window.removeSelected = function() {
      if (!selectedObject) return;

      const index = furnitureObjects.indexOf(selectedObject);
      if (index >= 0) {
        document.getElementById(`item-${index}`)?.classList.remove('placed');
        selectedObject.userData.placed = false;
        selectedObject.visible = false;

        const placedIndex = placedFurniture.indexOf(selectedObject);
        if (placedIndex >= 0) placedFurniture.splice(placedIndex, 1);

        selectObject(null);
        setupDragControls();
        updateStats();
      }
    };

    // ==================== BLF ìë™ ë°°ì¹˜ ì•Œê³ ë¦¬ì¦˜ ====================
    window.autoPlace = function() {
      // 1. ë¯¸ë°°ì¹˜ ê°€êµ¬ë¥¼ ë¶€í”¼ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
      const unplacedItems = [];
      furnitureObjects.forEach((mesh, index) => {
        if (!mesh.userData.placed) {
          const { width, depth, height } = mesh.userData;
          unplacedItems.push({
            mesh,
            index,
            volume: width * depth * height,
            width, depth, height
          });
        }
      });

      // ë¶€í”¼ê°€ í° ê²ƒë¶€í„° ë°°ì¹˜ (Decreasing First Fit)
      unplacedItems.sort((a, b) => b.volume - a.volume);

      // 2. Height Map ì´ˆê¸°í™” (ê·¸ë¦¬ë“œ ê¸°ë°˜ ë†’ì´ ì¶”ì )
      const GRID_SIZE = 0.05; // 5cm ê·¸ë¦¬ë“œ
      const gridW = Math.ceil(currentTruck.width / GRID_SIZE);
      const gridD = Math.ceil(currentTruck.depth / GRID_SIZE);
      const heightMap = Array(gridW).fill(null).map(() => Array(gridD).fill(0));

      // ì´ë¯¸ ë°°ì¹˜ëœ ê°€êµ¬ë¡œ heightMap ì´ˆê¸°í™”
      placedFurniture.forEach(mesh => {
        const { width, depth, height } = mesh.userData;
        const pos = mesh.position;
        updateHeightMap(heightMap, pos.x, pos.z, width, depth, pos.y + height / 2, GRID_SIZE, currentTruck);
      });

      // 3. BLF ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ê° ê°€êµ¬ ë°°ì¹˜ (íšŒì „ ìµœì í™” í¬í•¨)
      for (const item of unplacedItems) {
        const bestPos = findBLFPositionWithRotation(
          item.width, item.depth, item.height,
          heightMap, GRID_SIZE, currentTruck
        );

        if (bestPos) {
          const { mesh, index } = item;
          mesh.userData.placed = true;
          mesh.visible = true;
          mesh.position.set(bestPos.x, bestPos.y + item.height / 2, bestPos.z);

          // íšŒì „ ì ìš©
          if (bestPos.rotated) {
            mesh.rotation.y = Math.PI / 2;
            // userDataë„ ì—…ë°ì´íŠ¸ (ë“œë˜ê·¸ ì‹œ ì¹˜ìˆ˜ ì°¸ì¡°ìš©)
            mesh.userData.width = bestPos.width;
            mesh.userData.depth = bestPos.depth;
          }

          placedFurniture.push(mesh);
          document.getElementById(`item-${index}`).classList.add('placed');

          // heightMap ì—…ë°ì´íŠ¸ (íšŒì „ ì ìš©ëœ ì¹˜ìˆ˜ ì‚¬ìš©)
          updateHeightMap(heightMap, bestPos.x, bestPos.z, bestPos.width, bestPos.depth, bestPos.y + item.height, GRID_SIZE, currentTruck);
        }
      }

      setupDragControls();
      updateStats();

      // ì ì¬ìœ¨ í‘œì‹œ
      const loadPercent = document.getElementById('load-percent').textContent;
      console.log(`BLF ìë™ ë°°ì¹˜ ì™„ë£Œ: ì ì¬ìœ¨ ${loadPercent}%`);
    };

    // ==================== ì„œë²„ ìµœì í™” (py3dbp) ====================
    window.serverOptimize = async function() {
      // ë¯¸ë°°ì¹˜ ê°€êµ¬ ìˆ˜ì§‘
      const unplacedItems = [];
      furnitureObjects.forEach((mesh, index) => {
        if (!mesh.userData.placed) {
          unplacedItems.push({
            id: mesh.userData.id,
            index: index,
            width: mesh.userData.width,
            depth: mesh.userData.depth,
            height: mesh.userData.height
          });
        }
      });

      if (unplacedItems.length === 0) {
        alert('ë°°ì¹˜í•  ê°€êµ¬ê°€ ì—†ìŠµë‹ˆë‹¤.');
        return;
      }

      // íŠ¸ëŸ­ íƒ€ì… ê²°ì •
      const truckType = document.querySelector('.truck-btn.active')?.dataset.truck || '2.5ton';

      setLoading(true, 'ì„œë²„ ìµœì í™” ê³„ì‚° ì¤‘...');

      try {
        const response = await fetch('/simulation/optimize', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            truck_type: truckType,
            items: unplacedItems.map(item => ({
              id: item.id,
              width: item.width,
              depth: item.depth,
              height: item.height
            })),
            algorithm: 'auto'
          })
        });

        if (!response.ok) throw new Error('Optimization failed');

        const result = await response.json();
        console.log('ì„œë²„ ìµœì í™” ê²°ê³¼:', result);

        // ê²°ê³¼ ì ìš©
        for (const placement of result.placements) {
          const item = unplacedItems.find(i => i.id === placement.id);
          if (!item) continue;

          const mesh = furnitureObjects[item.index];
          mesh.userData.placed = true;
          mesh.visible = true;
          mesh.position.set(placement.x, placement.y + placement.height / 2, placement.z);

          // íšŒì „ ì ìš©
          if (placement.rotated) {
            mesh.rotation.y = Math.PI / 2;
            mesh.userData.width = placement.width;
            mesh.userData.depth = placement.depth;
          }

          placedFurniture.push(mesh);
          document.getElementById(`item-${item.index}`).classList.add('placed');
        }

        setupDragControls();
        updateStats();

        // ê²°ê³¼ ì•Œë¦¼
        const algo = result.algorithm === 'py3dbp' ? 'py3dbp (ê³ ê¸‰)' : 'BLF';
        alert(`${algo} ìµœì í™” ì™„ë£Œ!\nì ì¬ìœ¨: ${result.load_percent}%\në°°ì¹˜: ${result.placements.length}ê°œ\në¯¸ë°°ì¹˜: ${result.unplaced_ids.length}ê°œ`);

      } catch (error) {
        console.error('ì„œë²„ ìµœì í™” ì‹¤íŒ¨:', error);
        alert('ì„œë²„ ìµœì í™” ì‹¤íŒ¨. ë¡œì»¬ BLFë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”.');
      } finally {
        setLoading(false);
      }
    };

    // BLF with rotation: 0Â°ì™€ 90Â° ëª¨ë‘ ì‹œë„í•˜ì—¬ ë” ì¢‹ì€ ìœ„ì¹˜ ì„ íƒ
    function findBLFPositionWithRotation(itemW, itemD, itemH, heightMap, gridSize, truck) {
      // ì›ë˜ ë°©í–¥
      const pos0 = findBLFPosition(itemW, itemD, itemH, heightMap, gridSize, truck);
      // 90Â° íšŒì „
      const pos90 = findBLFPosition(itemD, itemW, itemH, heightMap, gridSize, truck);

      if (!pos0 && !pos90) return null;
      if (!pos0) return { ...pos90, rotated: true, width: itemD, depth: itemW };
      if (!pos90) return { ...pos0, rotated: false, width: itemW, depth: itemD };

      // BLF ìš°ì„ ìˆœìœ„ë¡œ ë¹„êµ: Y(ë‚®ì€) â†’ Z(ë’¤) â†’ X(ì™¼ìª½)
      if (pos0.y < pos90.y) return { ...pos0, rotated: false, width: itemW, depth: itemD };
      if (pos90.y < pos0.y) return { ...pos90, rotated: true, width: itemD, depth: itemW };
      if (pos0.z < pos90.z) return { ...pos0, rotated: false, width: itemW, depth: itemD };
      if (pos90.z < pos0.z) return { ...pos90, rotated: true, width: itemD, depth: itemW };
      if (pos0.x <= pos90.x) return { ...pos0, rotated: false, width: itemW, depth: itemD };
      return { ...pos90, rotated: true, width: itemD, depth: itemW };
    }

    // BLF: ê°€ì¥ ë‚®ì€ Y â†’ ê°€ì¥ ë’¤(Zê°€ ì‘ì€) â†’ ê°€ì¥ ì™¼ìª½(Xê°€ ì‘ì€) ìœ„ì¹˜ ì°¾ê¸°
    function findBLFPosition(itemW, itemD, itemH, heightMap, gridSize, truck) {
      const gridW = heightMap.length;
      const gridD = heightMap[0].length;
      const itemGridW = Math.ceil(itemW / gridSize);
      const itemGridD = Math.ceil(itemD / gridSize);

      let bestPos = null;
      let bestY = Infinity;
      let bestZ = Infinity;
      let bestX = Infinity;

      // ëª¨ë“  ê·¸ë¦¬ë“œ ìœ„ì¹˜ íƒìƒ‰
      for (let gz = 0; gz <= gridD - itemGridD; gz++) {
        for (let gx = 0; gx <= gridW - itemGridW; gx++) {
          // ì´ ìœ„ì¹˜ì—ì„œ ê°€êµ¬ë¥¼ ë†“ì„ ë•Œ í•„ìš”í•œ ìµœì†Œ Y (ì§€ì§€ë©´ ë†’ì´)
          let maxHeightAtPos = 0;
          for (let dx = 0; dx < itemGridW; dx++) {
            for (let dz = 0; dz < itemGridD; dz++) {
              maxHeightAtPos = Math.max(maxHeightAtPos, heightMap[gx + dx][gz + dz]);
            }
          }

          // íŠ¸ëŸ­ ë†’ì´ ì´ˆê³¼ ì²´í¬
          if (maxHeightAtPos + itemH > truck.height) continue;

          // BLF ìš°ì„ ìˆœìœ„: Y(ë‚®ì€) â†’ Z(ë’¤) â†’ X(ì™¼ìª½)
          if (maxHeightAtPos < bestY ||
              (maxHeightAtPos === bestY && gz < bestZ) ||
              (maxHeightAtPos === bestY && gz === bestZ && gx < bestX)) {
            bestY = maxHeightAtPos;
            bestZ = gz;
            bestX = gx;
            bestPos = {
              x: -truck.width / 2 + gx * gridSize + itemW / 2,
              y: maxHeightAtPos,
              z: -truck.depth / 2 + gz * gridSize + itemD / 2
            };
          }
        }
      }

      return bestPos;
    }

    // Height Map ì—…ë°ì´íŠ¸
    function updateHeightMap(heightMap, cx, cz, itemW, itemD, newHeight, gridSize, truck) {
      const gridW = heightMap.length;
      const gridD = heightMap[0].length;

      // ì¤‘ì‹¬ ì¢Œí‘œë¥¼ ê·¸ë¦¬ë“œ ì¸ë±ìŠ¤ë¡œ ë³€í™˜
      const startGx = Math.floor((cx - itemW / 2 + truck.width / 2) / gridSize);
      const startGz = Math.floor((cz - itemD / 2 + truck.depth / 2) / gridSize);
      const endGx = Math.ceil((cx + itemW / 2 + truck.width / 2) / gridSize);
      const endGz = Math.ceil((cz + itemD / 2 + truck.depth / 2) / gridSize);

      for (let gx = Math.max(0, startGx); gx < Math.min(gridW, endGx); gx++) {
        for (let gz = Math.max(0, startGz); gz < Math.min(gridD, endGz); gz++) {
          heightMap[gx][gz] = Math.max(heightMap[gx][gz], newHeight);
        }
      }
    }

    window.clearAll = function() {
      placedFurniture.forEach((mesh) => {
        mesh.userData.placed = false;
        mesh.visible = false;
      });
      placedFurniture = [];

      furnitureObjects.forEach((_, index) => {
        document.getElementById(`item-${index}`)?.classList.remove('placed');
      });

      selectObject(null);
      setupDragControls();
      updateStats();
    };

    window.resetCamera = function() {
      camera.position.set(6, 5, 6);
      orbitControls.target.set(0, 1, 0);
    };

    window.toggleHelp = function() {
      document.getElementById('help-tooltip').classList.toggle('visible');
    };

    // íŠ¸ëŸ­ ë³€ê²½
    document.querySelectorAll('.truck-btn').forEach((btn) => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.truck-btn').forEach((b) => b.classList.remove('active'));
        btn.classList.add('active');

        currentTruck = TRUCK_SPECS[btn.dataset.truck];
        createTruck(currentTruck);

        placedFurniture.forEach(clampToTruck);
        updateStats();
      });
    });

    // ==================== ì´ë²¤íŠ¸ ====================
    function setupEventListeners() {
      window.addEventListener('keydown', (e) => {
        if (!selectedObject) return;

        switch (e.key.toLowerCase()) {
          case 'w':
            moveSelectedUp();
            break;
          case 's':
            moveSelectedDown();
            break;
          case 'r':
            rotateSelected();
            break;
          case 'delete':
          case 'backspace':
            removeSelected();
            break;
          case 'escape':
            selectObject(null);
            break;
        }
      });

      window.addEventListener('resize', () => {
        const container = document.getElementById('canvas-container');
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });

      renderer.domElement.addEventListener('click', (e) => {
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const rect = renderer.domElement.getBoundingClientRect();

        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(placedFurniture);

        if (intersects.length === 0) {
          selectObject(null);
        }
      });
    }

    // ==================== í†µì‹  ====================
    function sendStateToApp() {
      const state = {
        type: 'stateUpdate',
        estimateId,
        truck: currentTruck,
        loadPercent: document.getElementById('load-percent').textContent,
        items: placedFurniture.map((obj) => ({
          id: obj.userData.id,
          label: obj.userData.label,
          position: { x: obj.position.x, y: obj.position.y, z: obj.position.z },
          rotation: obj.rotation.y,
        })),
      };

      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify(state));
      }
    }

    window.initSimulation = function(data) {
      estimateId = data.estimate_id;
      if (data.truck) {
        currentTruck = data.truck;
        createTruck(currentTruck);
      }
      if (data.furniture) {
        furnitureData = data.furniture;
        loadFurnitureItems(furnitureData);
      }
      setLoading(false);
    };

    // ==================== ì• ë‹ˆë©”ì´ì…˜ ====================
    function animate() {
      requestAnimationFrame(animate);
      orbitControls.update();
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
