<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>íŠ¸ëŸ­ ì ì¬ ì‹œë®¬ë ˆì´ì…˜</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
      touch-action: none;
    }

    #container {
      display: flex;
      height: 100vh;
      height: 100dvh;
    }

    /* ì‚¬ì´ë“œë°” (ê°€êµ¬ ëª©ë¡) */
    #sidebar {
      width: 140px;
      background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
      padding: 12px 8px;
      overflow-y: auto;
      border-right: 1px solid #dee2e6;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    #sidebar h3 {
      font-size: 14px;
      color: #495057;
      padding-bottom: 8px;
      border-bottom: 1px solid #dee2e6;
      margin-bottom: 4px;
    }

    .furniture-item {
      padding: 10px 8px;
      background: white;
      border-radius: 10px;
      cursor: pointer;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      transition: all 0.2s ease;
      border: 2px solid transparent;
    }

    .furniture-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .furniture-item.placed {
      opacity: 0.4;
      cursor: not-allowed;
      border-color: #28a745;
    }

    .furniture-item.selected {
      border-color: #007bff;
      background: #e7f1ff;
    }

    .furniture-icon { font-size: 28px; margin-bottom: 4px; }
    .furniture-name { font-size: 11px; color: #495057; font-weight: 500; }
    .furniture-size { font-size: 9px; color: #868e96; margin-top: 2px; }

    /* ìº”ë²„ìŠ¤ ì»¨í…Œì´ë„ˆ */
    #canvas-container {
      flex: 1;
      position: relative;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    /* ìƒë‹¨ ì»¨íŠ¸ë¡¤ */
    #top-controls {
      position: absolute;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 100;
    }

    #truck-selector { display: flex; gap: 10px; }

    .truck-btn {
      padding: 21px 30px;
      border: none;
      border-radius: 14px;
      background: rgba(255,255,255,0.9);
      font-size: 24px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .truck-btn:hover { background: white; transform: scale(1.05); }
    .truck-btn.active { background: #007bff; color: white; }

    #action-buttons { display: flex; gap: 14px; }

    .btn {
      padding: 21px 36px;
      border: none;
      border-radius: 16px;
      font-size: 24px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .btn-primary { background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); color: white; }
    .btn-secondary { background: rgba(255,255,255,0.9); color: #495057; }
    .btn-danger { background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); color: white; }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }

    /* í•˜ë‹¨ í†µê³„ */
    #stats-panel {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.85);
      color: white;
      padding: 16px 24px;
      border-radius: 16px;
      display: flex;
      gap: 32px;
      backdrop-filter: blur(10px);
      z-index: 100;
    }

    .stat-item { text-align: center; }
    .stat-value { font-size: 28px; font-weight: 700; color: #4dabf7; }
    .stat-value.warning { color: #ffc107; }
    .stat-value.danger { color: #ff6b6b; }
    .stat-label { font-size: 11px; color: #adb5bd; margin-top: 4px; }

    /* ì„ íƒëœ ê°€êµ¬ ì •ë³´ - ë†’ì´ ì¡°ì ˆ ì¶”ê°€ */
    #selected-info {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.95);
      padding: 12px 20px;
      border-radius: 12px;
      display: none;
      align-items: center;
      gap: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      z-index: 100;
    }

    #selected-info.visible { display: flex; }
    #selected-info .name { font-weight: 600; color: #212529; }
    #selected-info .size { font-size: 12px; color: #868e96; }
    #selected-info .height-info { font-size: 11px; color: #007bff; font-weight: 500; }

    .control-btn {
      padding: 21px 30px;
      border: 1px solid #dee2e6;
      border-radius: 14px;
      background: white;
      cursor: pointer;
      font-size: 27px;
      font-weight: 600;
    }

    .control-btn:hover { background: #f8f9fa; }
    .control-btn.danger { background: #ff6b6b; color: white; border: none; }

    .height-controls {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .height-btn {
      padding: 15px 24px;
      border: 1px solid #dee2e6;
      border-radius: 12px;
      background: white;
      cursor: pointer;
      font-size: 30px;
      font-weight: 600;
      line-height: 1;
    }

    .height-btn:hover { background: #e7f1ff; border-color: #007bff; }

    /* ë„ì›€ë§ */
    #help-tooltip {
      position: absolute;
      top: 60px;
      right: 12px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 12px 16px;
      border-radius: 10px;
      font-size: 12px;
      line-height: 1.6;
      max-width: 220px;
      display: none;
      z-index: 100;
    }

    #help-tooltip.visible { display: block; }

    /* ë¡œë”© */
    #loading {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255,255,255,0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 200;
    }

    #loading.hidden { display: none; }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid #007bff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #loading-text { margin-top: 16px; color: #495057; font-size: 14px; }

    /* ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰ í‘œì‹œê¸° (ì‘ì€ ë²„ì „) */
    #anim-progress {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 123, 255, 0.9);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 500;
      z-index: 100;
      display: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    #anim-progress.visible { display: block; }

    /* ëª¨ë“œ í‘œì‹œ */
    #mode-indicator {
      position: absolute;
      top: 60px;
      left: 12px;
      background: rgba(0,0,0,0.7);
      color: #4dabf7;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 12px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <div id="loading-text">ì‹œë®¬ë ˆì´í„° ë¡œë”© ì¤‘...</div>
  </div>
  <div id="anim-progress"></div>

  <div id="container">
    <div id="sidebar">
      <h3>ê°€êµ¬ ëª©ë¡</h3>
      <div id="furniture-list"></div>
    </div>

    <div id="canvas-container">
      <div id="top-controls">
        <div id="truck-selector">
          <button class="truck-btn" data-truck="1ton">1í†¤</button>
          <button class="truck-btn active" data-truck="2.5ton">2.5í†¤</button>
          <button class="truck-btn" data-truck="5ton">5í†¤</button>
        </div>
        <div id="action-buttons">
          <button class="btn btn-secondary" onclick="toggleHelp()">?</button>
          <button class="btn btn-secondary" onclick="resetCamera()">ì¹´ë©”ë¼</button>
          <button class="btn btn-primary" onclick="serverOptimize()">BLF</button>
          <button class="btn btn-primary" onclick="serverOptimizeOBB()" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);">OBB</button>
          <button class="btn btn-danger" onclick="clearAll()">ì´ˆê¸°í™”</button>
          <span id="align-status" style="padding: 8px 12px; border-radius: 8px; font-size: 12px; background: #17a2b8; color: white; margin-left: 8px;">ì •ë ¬ë¨</span>
        </div>
      </div>

      <div id="mode-indicator">XZ ì´ë™ | W/S: ë†’ì´ ì¡°ì ˆ</div>

      <div id="help-tooltip">
        <b>ì¡°ì‘ ë°©ë²•</b><br>
        - ê°€êµ¬ í´ë¦­: íŠ¸ëŸ­ì— ë°°ì¹˜<br>
        - ë“œë˜ê·¸: ê°€êµ¬ XZ ì´ë™<br>
        - W / S í‚¤: ë†’ì´ ì˜¬ë¦¬ê¸°/ë‚´ë¦¬ê¸°<br>
        - R í‚¤: 90ë„ íšŒì „<br>
        - Delete: ì œê±°<br>
        - ë‘ ì†ê°€ë½: ì¹´ë©”ë¼ íšŒì „/ì¤Œ
      </div>

      <div id="selected-info">
        <div>
          <div class="name" id="selected-name">ì†ŒíŒŒ</div>
          <div class="size" id="selected-size">200 x 90 x 85 cm</div>
          <div class="height-info" id="selected-height">ë†’ì´: 0 cm</div>
        </div>
        <div class="height-controls">
          <button class="height-btn" onclick="moveSelectedUp()">W</button>
          <button class="height-btn" onclick="moveSelectedDown()">S</button>
        </div>
        <button class="control-btn" onclick="rotateSelected()">90Â°</button>
        <button class="control-btn danger" onclick="removeSelected()">X</button>
      </div>

      <div id="stats-panel">
        <div class="stat-item">
          <div class="stat-value" id="load-percent">0</div>
          <div class="stat-label">ì ì¬ìœ¨ %</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="placed-count">0</div>
          <div class="stat-label">ë°°ì¹˜ë¨</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="total-count">0</div>
          <div class="stat-label">ì „ì²´</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="weight-total">0</div>
          <div class="stat-label">ë¬´ê²Œ kg</div>
        </div>
      </div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { DragControls } from 'three/addons/controls/DragControls.js';
    import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';

    // ==================== ì „ì—­ ìƒíƒœ ====================
    let scene, camera, renderer, orbitControls, dragControls;
    let truckMesh, truckFloor, truckWalls = [];
    let furnitureData = [];
    let furnitureObjects = [];
    let placedFurniture = [];
    let selectedObject = null;
    let estimateId = null;

    const plyLoader = new PLYLoader();
    const HEIGHT_STEP = 0.1; // ë†’ì´ ì¡°ì ˆ ë‹¨ìœ„ (10cm)
    const MAX_POINTS = 50000; // ìµœëŒ€ í¬ì¸íŠ¸ ìˆ˜ (ì„±ëŠ¥ ìµœì í™”)

    // í¬ì¸íŠ¸ ë‹¤ìš´ìƒ˜í”Œë§ í•¨ìˆ˜
    function downsampleGeometry(geometry, maxPoints) {
      const positions = geometry.attributes.position.array;
      const totalPoints = positions.length / 3;
      const stride = Math.ceil(totalPoints / maxPoints);

      const newPositions = [];
      const newColors = geometry.hasAttribute('color') ? [] : null;
      const colors = newColors ? geometry.attributes.color.array : null;

      for (let i = 0; i < totalPoints; i += stride) {
        const idx = i * 3;
        newPositions.push(positions[idx], positions[idx + 1], positions[idx + 2]);
        if (newColors) {
          newColors.push(colors[idx], colors[idx + 1], colors[idx + 2]);
        }
      }

      const newGeometry = new THREE.BufferGeometry();
      newGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
      if (newColors) {
        newGeometry.setAttribute('color', new THREE.Float32BufferAttribute(newColors, 3));
      }

      // bounding sphere ê³„ì‚° (frustum cullingìš©)
      newGeometry.computeBoundingSphere();

      return newGeometry;
    }

    const TRUCK_SPECS = {
      "1ton": { name: "1í†¤", width: 1.7, depth: 2.8, height: 1.7, maxWeight: 1000 },
      "2.5ton": { name: "2.5í†¤", width: 2.0, depth: 4.3, height: 1.9, maxWeight: 2500 },
      "5ton": { name: "5í†¤", width: 2.3, depth: 6.2, height: 2.4, maxWeight: 5000 },
    };

    let currentTruck = TRUCK_SPECS["2.5ton"];

    // ==================== ì´ˆê¸°í™” ====================
    function init() {
      const container = document.getElementById('canvas-container');

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e);

      camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
      camera.position.set(6, 5, 6);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(10, 15, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // Ground
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(20, 20),
        new THREE.MeshStandardMaterial({ color: 0x2d2d44, roughness: 0.8 })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.01;
      ground.receiveShadow = true;
      scene.add(ground);

      const gridHelper = new THREE.GridHelper(20, 20, 0x444466, 0x333355);
      scene.add(gridHelper);

      // Controls
      orbitControls = new OrbitControls(camera, renderer.domElement);
      orbitControls.enableDamping = true;
      orbitControls.dampingFactor = 0.05;
      orbitControls.target.set(0, 1, 0);
      orbitControls.maxPolarAngle = Math.PI / 2 - 0.1;

      createTruck(currentTruck);
      setupEventListeners();
      animate();

      const params = new URLSearchParams(window.location.search);
      estimateId = params.get('estimate_id');

      if (estimateId) {
        loadSimulationData(estimateId);
      } else {
        loadSampleData();
      }

      // ì •ë ¬ ìƒíƒœ í™•ì¸
      checkAlignmentStatus();
    }

    // ì •ë ¬ ìƒíƒœ í™•ì¸
    async function checkAlignmentStatus() {
      try {
        const res = await fetch('/simulation/alignment-status');
        const status = await res.json();
        const badge = document.getElementById('align-status');
        if (badge) {
          if (status.open3d_available) {
            badge.textContent = 'OBB ì •ë ¬ í™œì„±';
            badge.style.background = '#28a745';
          } else {
            badge.textContent = 'PLY ì •ë ¬ë¨';
            badge.style.background = '#17a2b8';
          }
        }
      } catch (e) {
        console.log('ì •ë ¬ ìƒíƒœ í™•ì¸ ì‹¤íŒ¨:', e);
      }
    }

    // ==================== íŠ¸ëŸ­ ìƒì„± ====================
    function createTruck(spec) {
      if (truckMesh) scene.remove(truckMesh);
      if (truckFloor) scene.remove(truckFloor);
      truckWalls.forEach(w => scene.remove(w));
      truckWalls = [];

      const { width, depth, height } = spec;

      // íŠ¸ëŸ­ í”„ë ˆì„
      const geometry = new THREE.BoxGeometry(width, height, depth);
      const edges = new THREE.EdgesGeometry(geometry);
      truckMesh = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ff88 }));
      truckMesh.position.set(0, height / 2, 0);
      scene.add(truckMesh);

      // ë°”ë‹¥
      truckFloor = new THREE.Mesh(
        new THREE.PlaneGeometry(width, depth),
        new THREE.MeshStandardMaterial({ color: 0x00ff88, transparent: true, opacity: 0.2, side: THREE.DoubleSide })
      );
      truckFloor.rotation.x = -Math.PI / 2;
      truckFloor.position.y = 0.005;
      scene.add(truckFloor);

      // ë²½ë©´
      const wallMaterial = new THREE.MeshStandardMaterial({
        color: 0x00ff88, transparent: true, opacity: 0.08, side: THREE.DoubleSide
      });

      const backWall = new THREE.Mesh(new THREE.PlaneGeometry(width, height), wallMaterial);
      backWall.position.set(0, height / 2, -depth / 2);
      scene.add(backWall);
      truckWalls.push(backWall);

      const sideWallL = new THREE.Mesh(new THREE.PlaneGeometry(depth, height), wallMaterial);
      sideWallL.rotation.y = Math.PI / 2;
      sideWallL.position.set(-width / 2, height / 2, 0);
      scene.add(sideWallL);
      truckWalls.push(sideWallL);

      const sideWallR = sideWallL.clone();
      sideWallR.position.x = width / 2;
      scene.add(sideWallR);
      truckWalls.push(sideWallR);
    }

    // ==================== ë°ì´í„° ë¡œë“œ ====================
    async function loadSimulationData(estId) {
      setLoading(true, 'ê°€êµ¬ ë°ì´í„° ë¡œë”© ì¤‘...');
      try {
        const response = await fetch(`/simulation/data/${estId}`);
        if (!response.ok) throw new Error('Failed');
        const data = await response.json();

        if (data.truck) {
          currentTruck = data.truck;
          createTruck(currentTruck);
        }

        furnitureData = data.furniture || [];
        await loadFurnitureItems(furnitureData);
        updateUI();
        setLoading(false);
      } catch (error) {
        console.error('Error:', error);
        loadSampleData();
      }
    }

    async function loadSampleData() {
      // API í˜¸ì¶œë¡œ ì‹¤ì œ PLY íŒŒì¼ í¬í•¨ëœ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
      try {
        const res = await fetch('/simulation/data/123');
        const data = await res.json();
        furnitureData = data.furniture || [];
        await loadFurnitureItems(furnitureData);
        updateUI();
        setLoading(false);
      } catch (err) {
        console.error('API í˜¸ì¶œ ì‹¤íŒ¨:', err);
        furnitureData = [];
        updateUI();
        setLoading(false);
      }
    }

    async function loadFurnitureItems(items) {
      console.log('=== loadFurnitureItems ì‹œì‘ ===');
      console.log('ì…ë ¥ ì•„ì´í…œ ìˆ˜:', items.length);

      furnitureObjects = [];
      const validItems = [];
      let loadedCount = 0;

      for (const item of items) {
        setLoading(true, `ê°€êµ¬ ë¡œë”© ì¤‘... (${++loadedCount}/${items.length})`);
        const mesh = await createFurnitureMesh(item);
        if (mesh) {
          console.log(`  ë¡œë“œ ì„±ê³µ: ${item.label}, placed=${mesh.userData.placed}`);
          furnitureObjects.push(mesh);
          validItems.push(item);
        } else {
          console.log(`  ë¡œë“œ ì‹¤íŒ¨/ìŠ¤í‚µ: ${item.label}`);
        }
      }

      furnitureData = validItems;
      createSidebar(validItems);
      document.getElementById('total-count').textContent = validItems.length;

      console.log('=== loadFurnitureItems ì™„ë£Œ ===');
      console.log('furnitureObjects ê°œìˆ˜:', furnitureObjects.length);
    }

    async function createFurnitureMesh(item) {
      return new Promise((resolve) => {
        const { width, height, depth, color, ply_url } = item;

        if (!ply_url) {
          // PLY ì—†ìœ¼ë©´ ìŠ¤í‚µ
          console.log(`PLY ì—†ìŒ, ìŠ¤í‚µ: ${item.label}`);
          resolve(null);
          return;
        }

        plyLoader.load(
          ply_url,
          (geometry) => {
            const originalCount = geometry.attributes.position.count;

            // í¬ì¸íŠ¸ ë‹¤ìš´ìƒ˜í”Œë§ (ì„±ëŠ¥ ìµœì í™”)
            if (originalCount > MAX_POINTS) {
              geometry = downsampleGeometry(geometry, MAX_POINTS);
              console.log(`ë‹¤ìš´ìƒ˜í”Œë§: ${originalCount} â†’ ${geometry.attributes.position.count} points`);
            }

            // Open3D (Z-up) â†’ Three.js (Y-up) ì¢Œí‘œê³„ ë³€í™˜
            // Xì¶• ê¸°ì¤€ -90ë„ íšŒì „ (Z-upì„ Y-upìœ¼ë¡œ)
            geometry.rotateX(-Math.PI / 2);

            geometry.computeBoundingBox();
            const bbox = geometry.boundingBox;
            const size = new THREE.Vector3();
            bbox.getSize(size);

            // ì¤‘ì‹¬ ë§ì¶”ê¸°
            geometry.center();

            // PLY ê· ì¼ ìŠ¤ì¼€ì¼ë§ (ì›ë³¸ ë¹„ìœ¨ ìœ ì§€)
            const scale = Math.min(width / size.x, height / size.y, depth / size.z);

            // ìŠ¤ì¼€ì¼ ì ìš© í›„ ì‹¤ì œ PLY í¬ê¸° ê³„ì‚°
            const scaledWidth = size.x * scale;
            const scaledHeight = size.y * scale;
            const scaledDepth = size.z * scale;

            // ê·¸ë£¹ ìƒì„± (íˆíŠ¸ë°•ìŠ¤ + í¬ì¸íŠ¸í´ë¼ìš°ë“œ)
            const group = new THREE.Group();
            // userDataëŠ” ìŠ¤ì¼€ì¼ ì ìš©ëœ ì‹¤ì œ í¬ê¸°ë¡œ ì €ì¥
            group.userData = {
              ...item,
              width: scaledWidth,
              height: scaledHeight,
              depth: scaledDepth,
              placed: false,
              baseY: scaledHeight / 2,
              isPoints: true
            };

            // í¬ì¸íŠ¸ í´ë¼ìš°ë“œ (ë‹¤ìš´ìƒ˜í”Œë§ í›„ í¬ì¸íŠ¸ í¬ê¸° ì¡°ì ˆ)
            const pointSize = originalCount > MAX_POINTS ? 0.015 : 0.008;
            const pointsMaterial = new THREE.PointsMaterial({
              size: pointSize,
              vertexColors: geometry.hasAttribute('color'),
              sizeAttenuation: true,
            });
            const points = new THREE.Points(geometry, pointsMaterial);
            points.scale.setScalar(scale);  // ê· ì¼ ìŠ¤ì¼€ì¼ë§ (ì›ë³¸ ë¹„ìœ¨ ìœ ì§€)
            points.frustumCulled = false; // frustum culling ë¹„í™œì„±í™” (ì‚¬ë¼ì§ ë°©ì§€)
            group.add(points);

            // íˆíŠ¸ë°•ìŠ¤ - PLY ì‹¤ì œ í¬ê¸°ì— ë”± ë§ê²Œ
            const hitboxGeometry = new THREE.BoxGeometry(scaledWidth, scaledHeight, scaledDepth);
            const hitboxMaterial = new THREE.MeshBasicMaterial({
              transparent: true,
              opacity: 0.15,
              depthWrite: false,
              color: color || 0x4488ff,
            });
            const hitbox = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
            hitbox.userData.isHitbox = true;
            group.add(hitbox);

            // íˆíŠ¸ë°•ìŠ¤ ì—£ì§€ (ê²½ê³„ì„ )
            const hitboxEdges = new THREE.EdgesGeometry(hitboxGeometry);
            const hitboxLine = new THREE.LineSegments(hitboxEdges, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true }));
            group.add(hitboxLine);

            group.visible = false;
            scene.add(group);

            console.log(`PLY ë¡œë“œ ì„±ê³µ: ${item.label} (${geometry.attributes.position.count} points)`);
            resolve(group);
          },
          (progress) => {
            if (progress.total) {
              const pct = Math.round((progress.loaded / progress.total) * 100);
              setLoading(true, `${item.label} ë¡œë”©... ${pct}%`);
            }
          },
          (error) => {
            console.warn(`PLY ë¡œë“œ ì‹¤íŒ¨, ìŠ¤í‚µ: ${item.label}`, error);
            resolve(null);
          }
        );
      });
    }

    // ==================== UI ====================
    function createSidebar(items) {
      const container = document.getElementById('furniture-list');
      container.innerHTML = '';

      items.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'furniture-item';
        div.id = `item-${index}`;
        div.innerHTML = `
          <div class="furniture-icon">${getEmoji(item.label)}</div>
          <div class="furniture-name">${item.label_ko || item.label}</div>
          <div class="furniture-size">${(item.width * 100).toFixed(0)}x${(item.depth * 100).toFixed(0)}</div>
        `;
        div.onclick = () => placeFurniture(index);
        container.appendChild(div);
      });
    }

    function getEmoji(label) {
      const l = label.toLowerCase();
      if (l.includes('sofa')) return 'ğŸ›‹ï¸';
      if (l.includes('chair')) return 'ğŸª‘';
      if (l.includes('table')) return 'ğŸ½ï¸';
      if (l.includes('desk')) return 'ğŸ–¥ï¸';
      if (l.includes('bed')) return 'ğŸ›ï¸';
      if (l.includes('wardrobe') || l.includes('closet')) return 'ğŸšª';
      if (l.includes('cabinet')) return 'ğŸ—„ï¸';
      return 'ğŸ“¦';
    }

    function updateUI() {
      updateStats();
      updateSelectedInfo();
    }

    function updateStats() {
      const truckVolume = currentTruck.width * currentTruck.depth * currentTruck.height;
      let placedVolume = 0;
      let totalWeight = 0;

      placedFurniture.forEach((mesh) => {
        const { width, depth, height, weight } = mesh.userData;
        placedVolume += width * depth * height;
        totalWeight += weight || 0;
      });

      const loadPercent = Math.round((placedVolume / truckVolume) * 100);

      const loadEl = document.getElementById('load-percent');
      loadEl.textContent = loadPercent;
      loadEl.className = 'stat-value' + (loadPercent > 90 ? ' danger' : loadPercent > 70 ? ' warning' : '');

      document.getElementById('placed-count').textContent = placedFurniture.length;

      const weightEl = document.getElementById('weight-total');
      weightEl.textContent = totalWeight;
      weightEl.className = 'stat-value' + (totalWeight > currentTruck.maxWeight ? ' danger' : '');

      sendStateToApp();
    }

    function updateSelectedInfo() {
      const infoPanel = document.getElementById('selected-info');

      if (selectedObject) {
        infoPanel.classList.add('visible');
        document.getElementById('selected-name').textContent = selectedObject.userData.label_ko || selectedObject.userData.label;
        document.getElementById('selected-size').textContent =
          `${(selectedObject.userData.width * 100).toFixed(0)} x ${(selectedObject.userData.depth * 100).toFixed(0)} x ${(selectedObject.userData.height * 100).toFixed(0)} cm`;

        // ë°”ë‹¥ìœ¼ë¡œë¶€í„°ì˜ ë†’ì´ ê³„ì‚°
        const floorY = selectedObject.position.y - selectedObject.userData.height / 2;
        document.getElementById('selected-height').textContent = `ë°”ë‹¥ì—ì„œ ë†’ì´: ${(floorY * 100).toFixed(0)} cm`;
      } else {
        infoPanel.classList.remove('visible');
      }
    }

    function setLoading(show, text = 'ë¡œë”© ì¤‘...') {
      document.getElementById('loading').classList.toggle('hidden', !show);
      document.getElementById('loading-text').textContent = text;
    }

    // ==================== ê°€êµ¬ ë°°ì¹˜ ====================
    function placeFurniture(index) {
      const mesh = furnitureObjects[index];
      if (!mesh || mesh.userData.placed) return;

      mesh.userData.placed = true;
      mesh.visible = true;

      // ë¹ˆ ê³µê°„ ì°¾ê¸°
      const pos = findEmptyPosition(mesh);
      mesh.position.set(pos.x, mesh.userData.height / 2, pos.z);

      placedFurniture.push(mesh);
      document.getElementById(`item-${index}`).classList.add('placed');

      setupDragControls();
      updateStats();
      selectObject(mesh);
    }

    // ë¹ˆ ê³µê°„ ì°¾ê¸° (ê·¸ë¦¬ë“œ íƒìƒ‰)
    function findEmptyPosition(mesh) {
      const { width, depth } = mesh.userData;
      const step = 0.1; // 10cm ë‹¨ìœ„ë¡œ íƒìƒ‰

      // íŠ¸ëŸ­ ì¤‘ì•™ë¶€í„° ì‹œì‘í•´ì„œ ë‚˜ì„ í˜•ìœ¼ë¡œ íƒìƒ‰
      for (let radius = 0; radius < Math.max(currentTruck.width, currentTruck.depth); radius += step) {
        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;

          // ê²½ê³„ ì²´í¬
          const hw = currentTruck.width / 2 - width / 2;
          const hd = currentTruck.depth / 2 - depth / 2;
          if (Math.abs(x) > hw || Math.abs(z) > hd) continue;

          // ì„ì‹œë¡œ ìœ„ì¹˜ ì„¤ì •
          mesh.position.set(x, mesh.userData.height / 2, z);

          // ì¶©ëŒ ê²€ì‚¬
          if (!checkCollision(mesh)) {
            return { x, z };
          }
        }
      }

      // ë¹ˆ ê³µê°„ ì—†ìœ¼ë©´ ì›ì 
      return { x: 0, z: 0 };
    }

    let dragStartY = 0; // ë“œë˜ê·¸ ì‹œì‘ ì‹œ Y ì¢Œí‘œ ì €ì¥
    let dragLastValidPos = new THREE.Vector3(); // ë§ˆì§€ë§‰ ìœ íš¨ ìœ„ì¹˜

    function setupDragControls() {
      if (dragControls) dragControls.dispose();

      dragControls = new DragControls(placedFurniture, camera, renderer.domElement);

      dragControls.addEventListener('dragstart', (event) => {
        orbitControls.enabled = false;
        selectObject(event.object);
        // ë“œë˜ê·¸ ì‹œì‘ ì‹œ Y ì¢Œí‘œì™€ ìœ„ì¹˜ ì €ì¥
        dragStartY = event.object.position.y;
        dragLastValidPos.copy(event.object.position);
      });

      dragControls.addEventListener('drag', (event) => {
        const obj = event.object;
        // Y ì¢Œí‘œ ê³ ì •
        obj.position.y = dragStartY;
        // XZë§Œ ê²½ê³„ ì²´í¬
        clampToTruckXZ(obj);

        // ì¶©ëŒ ê²€ì‚¬
        if (checkCollision(obj)) {
          // ì¶©ëŒí•˜ë©´ ë§ˆì§€ë§‰ ìœ íš¨ ìœ„ì¹˜ë¡œ ë³µì›
          obj.position.copy(dragLastValidPos);
        } else {
          // ì¶©ëŒ ì—†ìœ¼ë©´ ìœ íš¨ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
          dragLastValidPos.copy(obj.position);
        }

        updateSelectedInfo();
      });

      dragControls.addEventListener('dragend', () => {
        orbitControls.enabled = true;
        updateStats();
      });
    }

    // ì¶©ëŒ ê²€ì‚¬ (AABB) - userData í¬ê¸° ê¸°ë°˜
    function checkCollision(obj) {
      // userDataì—ì„œ ì‹¤ì œ í¬ê¸°ë¡œ ë°”ìš´ë”© ë°•ìŠ¤ ìƒì„± (PLY ìŠ¤ì¼€ì¼ ë¬¸ì œ ë°©ì§€)
      const { width, height, depth } = obj.userData;
      const pos = obj.position;

      // pos.yëŠ” ì¤‘ì‹¬ ì¢Œí‘œì´ë¯€ë¡œ height/2ë¥¼ ë¹¼ì„œ ë°”ë‹¥ ì¢Œí‘œë¡œ ë³€í™˜
      const yBottom = pos.y - height / 2;
      const box1 = new THREE.Box3(
        new THREE.Vector3(pos.x - width/2 + 0.01, yBottom + 0.01, pos.z - depth/2 + 0.01),
        new THREE.Vector3(pos.x + width/2 - 0.01, yBottom + height - 0.01, pos.z + depth/2 - 0.01)
      );

      for (const other of placedFurniture) {
        if (other === obj) continue;
        if (!other.userData.placed) continue;  // ë°°ì¹˜ëœ ê°ì²´ë§Œ ê²€ì‚¬

        const otherData = other.userData;
        const otherPos = other.position;

        // otherPos.yë„ ì¤‘ì‹¬ ì¢Œí‘œì´ë¯€ë¡œ height/2ë¥¼ ë¹¼ì„œ ë°”ë‹¥ ì¢Œí‘œë¡œ ë³€í™˜
        const otherYBottom = otherPos.y - otherData.height / 2;
        const box2 = new THREE.Box3(
          new THREE.Vector3(otherPos.x - otherData.width/2, otherYBottom, otherPos.z - otherData.depth/2),
          new THREE.Vector3(otherPos.x + otherData.width/2, otherYBottom + otherData.height, otherPos.z + otherData.depth/2)
        );

        if (box1.intersectsBox(box2)) {
          return true;
        }
      }
      return false;
    }

    function clampToTruckXZ(obj) {
      const { width, depth } = obj.userData;
      const hw = currentTruck.width / 2 - width / 2;
      const hd = currentTruck.depth / 2 - depth / 2;

      obj.position.x = Math.max(-hw, Math.min(hw, obj.position.x));
      obj.position.z = Math.max(-hd, Math.min(hd, obj.position.z));
    }

    function clampToTruck(obj) {
      const { width, depth, height } = obj.userData;

      // íŠ¸ëŸ­ ê²½ê³„
      const halfTruckW = currentTruck.width / 2;
      const halfTruckD = currentTruck.depth / 2;

      // ê°ì²´ ê²½ê³„ (ì¤‘ì‹¬ì—ì„œ ê°€ì¥ìë¦¬ê¹Œì§€)
      const halfW = width / 2;
      const halfD = depth / 2;
      const halfH = height / 2;

      // X ë²”ìœ„: -halfTruckW + halfW ~ halfTruckW - halfW
      const minX = -halfTruckW + halfW;
      const maxX = halfTruckW - halfW;
      obj.position.x = Math.max(minX, Math.min(maxX, obj.position.x));

      // Z ë²”ìœ„: -halfTruckD + halfD ~ halfTruckD - halfD
      const minZ = -halfTruckD + halfD;
      const maxZ = halfTruckD - halfD;
      obj.position.z = Math.max(minZ, Math.min(maxZ, obj.position.z));

      // Y ë²”ìœ„: halfH ~ truckHeight - halfH
      const minY = halfH;
      const maxY = currentTruck.height - halfH;
      obj.position.y = Math.max(minY, Math.min(maxY, obj.position.y));

    }

    function selectObject(obj) {
      // ì´ì „ ì„ íƒ í•´ì œ
      if (selectedObject && selectedObject !== obj) {
        setSelectionHighlight(selectedObject, false);
      }

      selectedObject = obj;

      furnitureObjects.forEach((m, i) => {
        document.getElementById(`item-${i}`)?.classList.remove('selected');
      });

      if (obj) {
        const index = furnitureObjects.indexOf(obj);
        document.getElementById(`item-${index}`)?.classList.add('selected');
        setSelectionHighlight(obj, true);
      }

      updateSelectedInfo();
    }

    function setSelectionHighlight(obj, selected) {
      if (!obj) return;

      // Groupì¸ ê²½ìš° íˆíŠ¸ë°•ìŠ¤ ì°¾ì•„ì„œ í‘œì‹œ
      if (obj.isGroup) {
        obj.children.forEach(child => {
          if (child.userData.isHitbox) {
            child.material.opacity = selected ? 0.15 : 0.0;
            child.material.color.setHex(selected ? 0x00ff00 : 0xffffff);
          }
        });
      } else if (obj.material && obj.material.emissive) {
        obj.material.emissive.setHex(selected ? 0x333333 : 0x000000);
      }
    }

    // ==================== ë†’ì´ ì¡°ì ˆ ====================
    window.moveSelectedUp = function() {
      if (!selectedObject) return;
      const oldY = selectedObject.position.y;
      selectedObject.position.y += HEIGHT_STEP;
      clampToTruck(selectedObject);

      // ì¶©ëŒ ì‹œ ë³µì›
      if (checkCollision(selectedObject)) {
        selectedObject.position.y = oldY;
      }

      updateSelectedInfo();
      updateStats();
    };

    window.moveSelectedDown = function() {
      if (!selectedObject) return;
      const oldY = selectedObject.position.y;
      selectedObject.position.y -= HEIGHT_STEP;
      clampToTruck(selectedObject);

      // ì¶©ëŒ ì‹œ ë³µì›
      if (checkCollision(selectedObject)) {
        selectedObject.position.y = oldY;
      }

      updateSelectedInfo();
      updateStats();
    };

    // ==================== ì•¡ì…˜ ====================
    window.rotateSelected = function() {
      if (!selectedObject) return;

      // íšŒì „ ì „ ìƒíƒœ ì €ì¥
      const oldRotation = selectedObject.rotation.y;
      const oldWidth = selectedObject.userData.width;
      const oldDepth = selectedObject.userData.depth;

      selectedObject.rotation.y += Math.PI / 2;

      // ì¹˜ìˆ˜ ìŠ¤ì™‘
      selectedObject.userData.width = oldDepth;
      selectedObject.userData.depth = oldWidth;

      clampToTruck(selectedObject);

      // ì¶©ëŒ ì‹œ ë³µì›
      if (checkCollision(selectedObject)) {
        selectedObject.rotation.y = oldRotation;
        selectedObject.userData.width = oldWidth;
        selectedObject.userData.depth = oldDepth;
      }

      updateSelectedInfo();
    };

    window.removeSelected = function() {
      if (!selectedObject) return;

      const index = furnitureObjects.indexOf(selectedObject);
      if (index >= 0) {
        document.getElementById(`item-${index}`)?.classList.remove('placed');
        selectedObject.userData.placed = false;
        selectedObject.visible = false;

        const placedIndex = placedFurniture.indexOf(selectedObject);
        if (placedIndex >= 0) placedFurniture.splice(placedIndex, 1);

        selectObject(null);
        setupDragControls();
        updateStats();
      }
    };

    // ==================== ì„œë²„ ìµœì í™” ====================
    window.serverOptimize = async function() {
      console.log('=== serverOptimize í˜¸ì¶œ ===');

      // ë¨¼ì € ëª¨ë“  ê°€êµ¬ ì´ˆê¸°í™”
      resetAllFurniture();

      // ëª¨ë“  ê°€êµ¬ ìˆ˜ì§‘
      const items = [];
      furnitureObjects.forEach((mesh, index) => {
        if (mesh) {
          items.push({
            id: mesh.userData.id,
            index: index,
            width: mesh.userData.width,
            depth: mesh.userData.depth,
            height: mesh.userData.height
          });
        }
      });

      console.log('ë°°ì¹˜í•  ê°€êµ¬ ìˆ˜:', items.length);

      if (items.length === 0) {
        alert('ê°€êµ¬ê°€ ì—†ìŠµë‹ˆë‹¤.');
        return;
      }

      const truckType = document.querySelector('.truck-btn.active')?.dataset.truck || '2.5ton';
      setLoading(true, 'ìµœì í™” ê³„ì‚° ì¤‘...');

      try {
        const response = await fetch('/simulation/optimize', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            truck_type: truckType,
            items: items.map(item => ({
              id: item.id,
              width: item.width,
              depth: item.depth,
              height: item.height
            })),
            algorithm: 'blf'
          })
        });

        if (!response.ok) throw new Error('Optimization failed');

        const result = await response.json();
        console.log('ìµœì í™” ê²°ê³¼:', result);

        // ê²°ê³¼ ì ìš©
        for (const placement of result.placements) {
          const item = items.find(i => i.id === placement.id);
          if (!item) continue;

          const mesh = furnitureObjects[item.index];

          if (placement.rotated) {
            mesh.rotation.y = Math.PI / 2;
            mesh.userData.width = placement.width;
            mesh.userData.depth = placement.depth;
          } else {
            mesh.rotation.y = 0;
          }

          const posY = placement.y + mesh.userData.height / 2;
          mesh.position.set(placement.x, posY, placement.z);
          clampToTruck(mesh);

          mesh.userData.placed = true;
          mesh.visible = true;

          placedFurniture.push(mesh);
          document.getElementById(`item-${item.index}`).classList.add('placed');
        }

        setupDragControls();
        updateStats();

        alert(`ìµœì í™” ì™„ë£Œ!\n${result.message}\nì ì¬ìœ¨: ${result.load_percent}%`);

      } catch (error) {
        console.error('ìµœì í™” ì‹¤íŒ¨:', error);
        alert('ìµœì í™” ì‹¤íŒ¨');
      } finally {
        setLoading(false);
      }
    };

    window.clearAll = function() {
      resetAllFurniture();
      updateStats();
    };

    // ==================== OBB ì„œë²„ ìµœì í™” ====================
    window.serverOptimizeOBB = async function() {
      console.log('=== serverOptimizeOBB í˜¸ì¶œ ===');

      // ë¨¼ì € ëª¨ë“  ê°€êµ¬ ì´ˆê¸°í™”
      resetAllFurniture();

      // ëª¨ë“  ê°€êµ¬ ìˆ˜ì§‘
      const items = [];
      furnitureObjects.forEach((mesh, index) => {
        if (mesh) {
          items.push({
            id: mesh.userData.id,
            index: index,
            width: mesh.userData.width,
            depth: mesh.userData.depth,
            height: mesh.userData.height
          });
        }
      });

      console.log('ë°°ì¹˜í•  ê°€êµ¬ ìˆ˜:', items.length);

      if (items.length === 0) {
        alert('ê°€êµ¬ê°€ ì—†ìŠµë‹ˆë‹¤.');
        return;
      }

      const truckType = document.querySelector('.truck-btn.active')?.dataset.truck || '2.5ton';
      setLoading(true, 'OBB ìµœì í™” ê³„ì‚° ì¤‘...');

      try {
        const response = await fetch('/simulation/optimize-obb', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            truck_type: truckType,
            items: items.map(item => ({
              id: item.id,
              width: item.width,
              depth: item.depth,
              height: item.height
            })),
            unit: 'm',
            support_ratio: 0.7
          })
        });

        if (!response.ok) throw new Error('OBB Optimization failed');

        const result = await response.json();
        console.log('OBB ìµœì í™” ê²°ê³¼:', result);

        // ì• ë‹ˆë©”ì´ì…˜ìœ¼ë¡œ ê²°ê³¼ ì ìš©
        setLoading(false);  // ê³„ì‚° ì™„ë£Œ, ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ ì „ ë¡œë”© í•´ì œ

        await animateOBBPlacements(result.placements, items, 300);

        const autoTruck = result.truck_type !== truckType ? ` (ê¶Œì¥: ${result.truck_type})` : '';
        alert(`OBB ìµœì í™” ì™„ë£Œ!\n${result.message}\nì ì¬ìœ¨: ${result.volume_utilization}%${autoTruck}`);

      } catch (error) {
        console.error('OBB ìµœì í™” ì‹¤íŒ¨:', error);
        alert('OBB ìµœì í™” ì‹¤íŒ¨');
      } finally {
        setLoading(false);
      }
    };

    // ëª¨ë“  ê°€êµ¬ ì´ˆê¸°í™” (ë°°ì¹˜ í•´ì œ)
    function resetAllFurniture() {
      placedFurniture.forEach((mesh) => {
        mesh.userData.placed = false;
        mesh.visible = false;
      });
      placedFurniture = [];

      furnitureObjects.forEach((mesh, index) => {
        if (mesh) {
          mesh.userData.placed = false;
          mesh.visible = false;
        }
        document.getElementById(`item-${index}`)?.classList.remove('placed');
      });

      selectObject(null);
      setupDragControls();
    }

    window.resetCamera = function() {
      camera.position.set(6, 5, 6);
      orbitControls.target.set(0, 1, 0);
    };

    window.toggleHelp = function() {
      document.getElementById('help-tooltip').classList.toggle('visible');
    };

    // íŠ¸ëŸ­ ë³€ê²½
    document.querySelectorAll('.truck-btn').forEach((btn) => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.truck-btn').forEach((b) => b.classList.remove('active'));
        btn.classList.add('active');

        currentTruck = TRUCK_SPECS[btn.dataset.truck];
        createTruck(currentTruck);

        placedFurniture.forEach(clampToTruck);
        updateStats();
      });
    });

    // ==================== ì´ë²¤íŠ¸ ====================
    function setupEventListeners() {
      window.addEventListener('keydown', (e) => {
        if (!selectedObject) return;

        switch (e.key.toLowerCase()) {
          case 'w':
            moveSelectedUp();
            break;
          case 's':
            moveSelectedDown();
            break;
          case 'r':
            rotateSelected();
            break;
          case 'delete':
          case 'backspace':
            removeSelected();
            break;
          case 'escape':
            selectObject(null);
            break;
        }
      });

      window.addEventListener('resize', () => {
        const container = document.getElementById('canvas-container');
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });

      renderer.domElement.addEventListener('click', (e) => {
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const rect = renderer.domElement.getBoundingClientRect();

        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(placedFurniture);

        if (intersects.length === 0) {
          selectObject(null);
        }
      });
    }

    // ==================== í†µì‹  ====================
    function sendStateToApp() {
      const state = {
        type: 'stateUpdate',
        estimateId,
        truck: currentTruck,
        loadPercent: document.getElementById('load-percent').textContent,
        items: placedFurniture.map((obj) => ({
          id: obj.userData.id,
          label: obj.userData.label,
          position: { x: obj.position.x, y: obj.position.y, z: obj.position.z },
          rotation: obj.rotation.y,
        })),
      };

      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify(state));
      }
    }

    window.initSimulation = function(data) {
      estimateId = data.estimate_id;
      if (data.truck) {
        currentTruck = data.truck;
        createTruck(currentTruck);
      }
      if (data.furniture) {
        furnitureData = data.furniture;
        loadFurnitureItems(furnitureData);
      }
      setLoading(false);
    };

    // ==================== ë°°ì¹˜ ì• ë‹ˆë©”ì´ì…˜ ì‹œìŠ¤í…œ ====================

    // Easing í•¨ìˆ˜
    const Easing = {
      // ë¶€ë“œëŸ¬ìš´ ê°ì†
      easeOutCubic: (t) => 1 - Math.pow(1 - t, 3),
      // ì‚´ì§ ì˜¤ë²„ìŠˆíŠ¸ í›„ ì•ˆì°©
      easeOutBack: (t) => {
        const c1 = 1.70158;
        const c3 = c1 + 1;
        return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
      },
      // ë°”ìš´ìŠ¤ íš¨ê³¼
      easeOutBounce: (t) => {
        const n1 = 7.5625;
        const d1 = 2.75;
        if (t < 1 / d1) return n1 * t * t;
        if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
        if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
        return n1 * (t -= 2.625 / d1) * t + 0.984375;
      }
    };

    // ì• ë‹ˆë©”ì´ì…˜ í
    let activeAnimations = [];
    let animationRunning = false;

    // ë‹¨ì¼ ê°ì²´ ì• ë‹ˆë©”ì´ì…˜
    function animatePlacement(mesh, targetPos, duration = 800, easing = Easing.easeOutCubic) {
      return new Promise((resolve) => {
        // ì‹œì‘ ìœ„ì¹˜: íŠ¸ëŸ­ ì•ìª½ (Z+) + ìœ„ìª½
        const startPos = {
          x: targetPos.x,
          y: targetPos.y + 0.5,  // ì•½ê°„ ìœ„ì—ì„œ ì‹œì‘
          z: currentTruck.depth / 2 + 1  // íŠ¸ëŸ­ ì• 1m ë°–ì—ì„œ ì‹œì‘
        };

        mesh.position.set(startPos.x, startPos.y, startPos.z);
        mesh.visible = true;

        const startTime = performance.now();

        const animation = {
          mesh,
          startPos,
          targetPos,
          startTime,
          duration,
          easing,
          resolve
        };

        activeAnimations.push(animation);
      });
    }

    // ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸ (ë§¤ í”„ë ˆì„ í˜¸ì¶œ)
    function updateAnimations() {
      const now = performance.now();
      const completed = [];

      for (const anim of activeAnimations) {
        const elapsed = now - anim.startTime;
        const progress = Math.min(elapsed / anim.duration, 1);
        const easedProgress = anim.easing(progress);

        // ìœ„ì¹˜ ë³´ê°„
        anim.mesh.position.x = anim.startPos.x + (anim.targetPos.x - anim.startPos.x) * easedProgress;
        anim.mesh.position.y = anim.startPos.y + (anim.targetPos.y - anim.startPos.y) * easedProgress;
        anim.mesh.position.z = anim.startPos.z + (anim.targetPos.z - anim.startPos.z) * easedProgress;

        if (progress >= 1) {
          // ìµœì¢… ìœ„ì¹˜ ì •í™•íˆ ì„¤ì •
          anim.mesh.position.set(anim.targetPos.x, anim.targetPos.y, anim.targetPos.z);
          completed.push(anim);
        }
      }

      // ì™„ë£Œëœ ì• ë‹ˆë©”ì´ì…˜ ì œê±°
      for (const anim of completed) {
        const idx = activeAnimations.indexOf(anim);
        if (idx > -1) activeAnimations.splice(idx, 1);
        anim.resolve();
      }
    }

    // ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰ í‘œì‹œê¸°
    function showAnimProgress(text) {
      const el = document.getElementById('anim-progress');
      el.textContent = text;
      el.classList.add('visible');
    }

    function hideAnimProgress() {
      document.getElementById('anim-progress').classList.remove('visible');
    }

    // OBB ë°°ì¹˜ ê²°ê³¼ ì• ë‹ˆë©”ì´ì…˜ (ìˆœì°¨ ì‹¤í–‰)
    async function animateOBBPlacements(placements, items, delay = 400) {
      animationRunning = true;

      for (let i = 0; i < placements.length; i++) {
        const placement = placements[i];
        const item = items.find(it => it.id === placement.id);
        if (!item) continue;

        const mesh = furnitureObjects[item.index];

        // íšŒì „ ì„¤ì •
        mesh.rotation.set(0, 0, 0);
        const isRotated = placement.orientation === 2 || placement.orientation === 3 || placement.orientation === 5;
        if (isRotated) {
          mesh.rotation.y = Math.PI / 2;
        }

        // ì¹˜ìˆ˜ ì—…ë°ì´íŠ¸
        mesh.userData.width = placement.width;
        mesh.userData.depth = placement.depth;
        mesh.userData.height = placement.height;

        // ìµœì¢… ìœ„ì¹˜ ê³„ì‚°
        const targetPos = {
          x: placement.x,
          y: placement.y + placement.height / 2,
          z: placement.z
        };

        // ìƒíƒœ ì—…ë°ì´íŠ¸
        mesh.userData.placed = true;
        placedFurniture.push(mesh);
        document.getElementById(`item-${item.index}`)?.classList.add('placed');

        // ì§„í–‰ í‘œì‹œ (í™”ë©´ í•˜ë‹¨ì— ì‘ê²Œ)
        showAnimProgress(`ì ì¬ ì¤‘... ${i + 1}/${placements.length}`);

        // ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰ ë° ëŒ€ê¸°
        await animatePlacement(mesh, targetPos, 600, Easing.easeOutBack);

        // ì• ë‹ˆë©”ì´ì…˜ í›„ íŠ¸ëŸ­ ê²½ê³„ ë‚´ë¡œ í´ë¨í•‘
        clampToTruckXZ(mesh);

        // ë‹¤ìŒ ê°ì²´ ì „ ë”œë ˆì´
        if (i < placements.length - 1) {
          await new Promise(r => setTimeout(r, delay));
        }
      }

      hideAnimProgress();
      setupDragControls();
      updateStats();
      animationRunning = false;
    }

    // ==================== ë Œë”ë§ ë£¨í”„ ====================
    function animate() {
      requestAnimationFrame(animate);
      updateAnimations();  // ë°°ì¹˜ ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸
      orbitControls.update();
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
